[🏠 Главная](../../README.md) → [☸️ Container-Orchestration](../../README.md#-container-orchestration) → [🔄 K-09-Жизненный-цикл-приложений](../../README.md#-k-09-жизненный-цикл-приложений)

---

# 🔗K-09-7-Multi-Container-PODs
>Много-контейнерные PODs: микросервисная архитектура, совместное использование сетевого пространства и томов, паттерны Sidecar, Adapter, Ambassador

---

<details>
<summary><b>🏗️Введение: микросервисы и много-контейнерные PODs</b></summary>

---

## О чем эта лекция

Привет и добро пожаловать в эту лекцию, посвященную много-контейнерным PODs.

Идея разделения большого монолитного приложения на суб-компоненты, известные как микросервисы, позволяет нам разрабатывать и развертывать наборы небольших, независимых друг от друга компонентов системы.

Эта архитектура может помочь нам масштабироваться вверх и вниз, а также изменять каждый кусочек этого пазла по мере необходимости, не изменяя сразу все приложение. За счет этого мы можем двигаться быстрее в разработке, отладке и проверке новых гипотез.

---

## Проблема: когда нужны связанные сервисы

Часто в наших задачах нам могут понадобиться две службы для совместной работы, такие как веб-сервер и служба регистрации метрик контейнера.

Нам нужен один экземпляр агента на каждый экземпляр веб-сервера, и они должны быть соединены друг с другом.

Мы не хотим объединять код этих двух служб, поскольку каждая из них нацелена на разные функции и может использоваться где-то еще. Также мы знаем, что нам наиболее просто и эффективно будет поддерживать эти службы, если они остануться как есть, т.е. разделенными.

А при объединении же кода вырастет сложность сопровождения и упадет скорость внедрения новых версий.

---

## Требования к совместной работе

Т.о. нам нужен только функционал этих двух приложений только для их совместной работы в текущем варианте развертывания.

Итак, нужен один агент для каждого экземпляра веб-сервера, и эти пары должны легко масштабироваться вместе.

Значит, эти контейнеры должны иметь:

1. **Один и тот же жизненный цикл** - они создаются вместе и уничтожаются вместе
2. **Одно и то же сетевое пространство** - они могут найти друг друга на общем localhost
3. **Доступ к одним и тем же томам хранилища** - для совместного использования данных

---

## Решение: много-контейнерные PODs

Это все есть в POD с несколькими контейнерами.

Таким образом, нам не нужно устанавливать совместное использование томов или настраивать services, чтобы обеспечить связь между контейнерами, составляющих много-контейнерный POD.

---

## Сравнение: монолит vs микросервисы vs много-контейнерные PODs

### Монолитное приложение

```
┌─────────────────────────────────────┐
│         Монолитное приложение        │
│  ┌────────────────────────────────┐ │
│  │  Веб-сервер + Мониторинг +      │ │
│  │  Логирование + Кэш + ...      │ │
│  │                                 │ │
│  │  Все в одном процессе           │ │
│  └────────────────────────────────┘ │
│                                     │
│  ❌ Сложно масштабировать           │
│  ❌ Сложно обновлять части          │
└─────────────────────────────────────┘
```

### Отдельные микросервисы (разные PODs)

```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│   POD #1     │  │   POD #2     │  │   POD #3     │
│  ┌─────────┐ │  │  ┌─────────┐ │  │  ┌─────────┐ │
│  │ Веб-    │ │  │  │ Монито- │ │  │  │ Логиро- │ │
│  │ сервер  │ │  │  │ ринг    │ │  │  │ вание   │ │
│  └─────────┘ │  │  └─────────┘ │  │  └─────────┘ │
└──────────────┘  └──────────────┘  └──────────────┘
      │                  │                  │
      └──────────────────┴──────────────────┘
                    │
            Service для связи
                    
❌ Нужны Services для связи
❌ Сложнее управлять масштабированием
✅ Независимое масштабирование
```

### Много-контейнерный POD

```
┌─────────────────────────────────────┐
│         POD (один IP)                │
│  ┌────────────────────────────────┐ │
│  │  Container: web-server         │ │
│  │  (порт 80)                     │ │
│  └────────────────────────────────┘ │
│  ┌────────────────────────────────┐ │
│  │  Container: cadvisor           │ │
│  │  (порт 8080)                   │ │
│  └────────────────────────────────┘ │
│                                     │
│  ✅ Общий lifecycle                  │
│  ✅ Общая сеть (localhost)          │
│  ✅ Общие volumes                    │
│  ✅ Простое масштабирование         │
└─────────────────────────────────────┘
```

---

</details>

<details>
<summary><b>⚙️Создание много-контейнерного POD</b></summary>

---

## Как это делается?

Добавим новый раздел в секцию `containers` в файл определения POD.

Как ты помнишь, что раздел контейнеров в спецификации POD является массивом. И причина, по которой это массив, состоит в том, чтобы разрешить нескольким контейнерам работать в одном POD.

---

## Пример Pod с несколькими контейнерами

В этом случае мы добавляем новый контейнер с именем `cadvisor` к нашему основному контейнеру с приложением.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
spec:
  containers:
  # Основной контейнер с веб-сервером
  - name: web-server
    image: nginx:latest
    ports:
    - containerPort: 80
    volumeMounts:
    - name: shared-storage
      mountPath: /var/www/html
  
  # Вспомогательный контейнер для сбора метрик
  - name: cadvisor
    image: gcr.io/cadvisor/cadvisor:latest
    ports:
    - containerPort: 8080
    volumeMounts:
    - name: shared-storage
      mountPath: /var/log
  volumes:
  - name: shared-storage
    emptyDir: {}
```

Теперь у нас здесь описание двух контейнеров.

---

## Архитектура много-контейнерного POD

```
┌─────────────────────────────────────────────────────────┐
│  POD: multi-container-pod                                │
│  IP: 10.244.1.5                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │                                                   │   │
│  │  Container: web-server                            │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Image: nginx:latest                        │ │   │
│  │  │  Port: 80                                   │ │   │
│  │  │  Volume: /var/www/html                      │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │                                                   │   │
│  │  Container: cadvisor                             │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Image: cadvisor:latest                     │ │   │
│  │  │  Port: 8080                                 │ │   │
│  │  │  Volume: /var/log                           │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │                                                   │   │
│  └──────────────────────────────────────────────────┘   │
│                                                          │
│  Shared Volume: shared-storage                           │
│  ┌──────────────────────────────────────────────────┐   │
│  │  emptyDir: {}                                    │   │
│  └──────────────────────────────────────────────────┘   │
│                                                          │
│  Network:                                                │
│  - Один IP для всех контейнеров                         │
│  - localhost:80 → web-server                            │
│  - localhost:8080 → cadvisor                            │
└─────────────────────────────────────────────────────────┘
```

---

## Преимущества много-контейнерных PODs

- **Общий lifecycle** - контейнеры создаются и удаляются вместе
- **Общая сеть** - контейнеры могут общаться через `localhost`
- **Общие volumes** - контейнеры могут совместно использовать данные
- **Простое масштабирование** - при масштабировании POD масштабируются все контейнеры вместе

---

</details>

<details>
<summary><b>🎨Паттерны проектирования много-контейнерных PODs</b></summary>

---

## Три основных паттерна

Существует три наиболее распространенных шаблона проектирования мульти-контейнерных PODs с учетом возложенных на них ролей.

---

## 1. Sidecar Pattern

Тот, который мы использовали сейчас называется **Sidecar**, и он используется для:

- Сбора метрик
- Перезагрузки настроек приложения в соседнем контейнере
- Логирования
- Мониторинга
- Кэширования

### Пример Sidecar

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-server-with-sidecar
spec:
  containers:
  - name: web-server
    image: nginx:latest
  - name: log-collector
    image: fluentd:latest
    # Собирает логи из web-server
```

В этом паттерне основной контейнер выполняет основную работу, а sidecar-контейнер предоставляет дополнительные функции.

### Схема Sidecar Pattern

```
┌─────────────────────────────────────┐
│  POD                                 │
│  ┌────────────────────────────────┐ │
│  │  Main Container               │ │
│  │  ┌──────────────────────────┐ │ │
│  │  │  web-server               │ │ │
│  │  │  Основная функциональность│ │ │
│  │  └──────────────────────────┘ │ │
│  │         │                       │ │
│  │         │ (логи, метрики)      │ │
│  │         ▼                       │ │
│  │  ┌──────────────────────────┐ │ │
│  │  │  Sidecar Container         │ │ │
│  │  │  log-collector             │ │ │
│  │  │  Вспомогательная функция   │ │ │
│  │  └──────────────────────────┘ │ │
│  └────────────────────────────────┘ │
└─────────────────────────────────────┘
```

---

## 2. Adapter Pattern

**Adapter** используется для:

- Нормализации вывода приложения
- Преобразования форматов данных
- Адаптации интерфейсов между сервисами

### Пример Adapter

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-with-adapter
spec:
  containers:
  - name: application
    image: my-app:latest
  - name: adapter
    image: adapter:latest
    # Преобразует формат метрик приложения
```

Adapter контейнер адаптирует вывод основного контейнера к стандартному формату.

### Схема Adapter Pattern

```
┌─────────────────────────────────────┐
│  POD                                 │
│  ┌────────────────────────────────┐ │
│  │  Main Container               │ │
│  │  ┌──────────────────────────┐ │ │
│  │  │  application              │ │ │
│  │  │  Вывод в формате A        │ │ │
│  │  └──────────────────────────┘ │ │
│  │         │                       │ │
│  │         │ (данные)             │ │
│  │         ▼                       │ │
│  │  ┌──────────────────────────┐ │ │
│  │  │  Adapter Container         │ │ │
│  │  │  adapter                   │ │ │
│  │  │  Преобразует A → B         │ │ │
│  │  └──────────────────────────┘ │ │
│  └────────────────────────────────┘ │
└─────────────────────────────────────┘
```

---

## 3. Ambassador Pattern

**Ambassador** используется для:

- Проксирования запросов
- Балансировки нагрузки
- Роутинга трафика
- Обработки SSL/TLS

### Пример Ambassador

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: app-with-ambassador
spec:
  containers:
  - name: application
    image: my-app:latest
  - name: ambassador
    image: envoy:latest
    # Проксирует запросы к application
```

Ambassador контейнер действует как прокси между внешним миром и основным контейнером.

### Схема Ambassador Pattern

```
        Внешний мир
             │
             │ (запросы)
             ▼
┌─────────────────────────────────────┐
│  POD                                 │
│  ┌────────────────────────────────┐ │
│  │  Ambassador Container          │ │
│  │  ┌──────────────────────────┐ │ │
│  │  │  envoy                     │ │ │
│  │  │  Прокси, балансировка,     │ │ │
│  │  │  SSL/TLS                   │ │ │
│  │  └──────────────────────────┘ │ │
│  │         │                       │ │
│  │         │ (проксирование)     │ │
│  │         ▼                       │ │
│  │  ┌──────────────────────────┐ │ │
│  │  │  Main Container           │ │ │
│  │  │  application              │ │ │
│  │  │  Основное приложение       │ │ │
│  │  └──────────────────────────┘ │ │
│  └────────────────────────────────┘ │
└─────────────────────────────────────┘
```

---

## Дополнительная информация

Это больше относится к разработке приложений и мы будем глубже рассматривать в курсе разработчика приложений в Kubernetes.

---

</details>

<details>
<summary><b>🌐Общая сеть в много-контейнерных PODs</b></summary>

---

## Общение через localhost

Контейнеры в одном POD разделяют одно сетевое пространство имен. Это означает, что они могут общаться друг с другом через `localhost`.

### Пример общения между контейнерами

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: network-example
spec:
  containers:
  - name: web-server
    image: nginx:latest
    ports:
    - containerPort: 80
  - name: metrics-collector
    image: prom/node-exporter:latest
    # Может обращаться к web-server через localhost:80
```

В этом примере `metrics-collector` может обращаться к `web-server` по адресу `localhost:80`.

### Схема общей сети

```
┌─────────────────────────────────────────────────────────┐
│  POD: network-example                                   │
│  IP: 10.244.1.10                                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │                                                   │   │
│  │  Container: web-server                            │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Слушает на порту 80                        │ │   │
│  │  │  localhost:80 → этот контейнер             │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │                                                   │   │
│  │  Container: metrics-collector                    │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Обращается к web-server:                   │ │   │
│  │  │  curl http://localhost:80                   │ │   │
│  │  │  ✅ Успешно! (общая сеть)                   │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │                                                   │   │
│  └──────────────────────────────────────────────────┘   │
│                                                          │
│  Общая сеть:                                            │
│  - Один IP-адрес для POD                                │
│  - Все контейнеры видят друг друга через localhost     │
│  - Порты должны быть уникальными                       │
└─────────────────────────────────────────────────────────┘
```

---

## Важные замечания

- Все контейнеры в POD используют один и тот же IP-адрес
- Порты должны быть уникальными для каждого контейнера
- Нет необходимости в Service для общения между контейнерами в одном POD

---

</details>

<details>
<summary><b>💾Общие Volumes в много-контейнерных PODs</b></summary>

---

## Совместное использование данных

Контейнеры в одном POD могут монтировать одни и те же volumes для совместного использования данных.

### Пример с общим Volume

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: shared-volume-example
spec:
  containers:
  - name: writer
    image: busybox:latest
    command: ['sh', '-c', 'echo "Hello" > /shared/data.txt']
    volumeMounts:
    - name: shared-data
      mountPath: /shared
  - name: reader
    image: busybox:latest
    command: ['sh', '-c', 'cat /shared/data.txt']
    volumeMounts:
    - name: shared-data
      mountPath: /shared
  volumes:
  - name: shared-data
    emptyDir: {}
```

Оба контейнера монтируют один и тот же volume, что позволяет им обмениваться данными.

### Схема общих Volumes

```
┌─────────────────────────────────────────────────────────┐
│  POD: shared-volume-example                              │
│  ┌──────────────────────────────────────────────────┐   │
│  │                                                   │   │
│  │  Container: writer                                │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Записывает данные:                         │ │   │
│  │  │  echo "Hello" > /shared/data.txt             │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │         │                                          │   │
│  │         │ (монтирует)                             │   │
│  │         ▼                                          │   │
│  │  ┌──────────────────────────────────────────┐    │   │
│  │  │  Volume: shared-data                      │    │   │
│  │  │  ┌────────────────────────────────────┐  │    │   │
│  │  │  │  /shared/data.txt                  │  │    │   │
│  │  │  │  "Hello"                            │  │    │   │
│  │  │  └────────────────────────────────────┘  │    │   │
│  │  └──────────────────────────────────────────┘    │   │
│  │         │                                          │   │
│  │         │ (монтирует тот же volume)                │   │
│  │         ▼                                          │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Container: reader                          │ │   │
│  │  │  ┌───────────────────────────────────────┐  │ │   │
│  │  │  │  Читает данные:                       │  │ │   │
│  │  │  │  cat /shared/data.txt                 │  │ │   │
│  │  │  │  Вывод: "Hello"                       │  │ │   │
│  │  │  └───────────────────────────────────────┘  │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │                                                   │   │
│  └──────────────────────────────────────────────────┘   │
│                                                          │
│  Общий Volume:                                          │
│  - Оба контейнера монтируют один volume                │
│  - Данные доступны обоим контейнерам                   │
│  - Изменения видны сразу                                │
└─────────────────────────────────────────────────────────┘
```

---

## Типы Volumes для совместного использования

- **emptyDir** - временное хранилище, существующее только пока POD жив
- **hostPath** - доступ к файлам на узле
- **PersistentVolumeClaim** - постоянное хранилище
- **ConfigMap/Secret** - конфигурационные данные

---

</details>

<details>
<summary><b>📊Практический пример: веб-сервер с мониторингом</b></summary>

---

## Сценарий

Веб-сервер, который нужно мониторить с помощью cAdvisor для сбора метрик контейнера.

---

## Полный пример

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-server-monitored
  labels:
    app: web-server
spec:
  containers:
  # Основной контейнер с веб-сервером
  - name: web-server
    image: nginx:latest
    ports:
    - containerPort: 80
      name: http
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "128Mi"
        cpu: "200m"
    volumeMounts:
    - name: html-content
      mountPath: /usr/share/nginx/html
  
  # Sidecar контейнер для мониторинга
  - name: cadvisor
    image: gcr.io/cadvisor/cadvisor:latest
    ports:
    - containerPort: 8080
      name: metrics
    volumeMounts:
    - name: rootfs
      mountPath: /rootfs
      readOnly: true
    - name: var-run
      mountPath: /var/run
      readOnly: true
    - name: sys
      mountPath: /sys
      readOnly: true
    - name: docker
      mountPath: /var/lib/docker
      readOnly: true
  
  volumes:
  - name: html-content
    emptyDir: {}
  - name: rootfs
    hostPath:
      path: /
  - name: var-run
    hostPath:
      path: /var/run
  - name: sys
    hostPath:
      path: /sys
  - name: docker
    hostPath:
      path: /var/lib/docker
```

---

## Как это работает

1. **web-server** контейнер обслуживает веб-контент на порту 80
2. **cadvisor** контейнер собирает метрики и предоставляет их на порту 8080
3. Оба контейнера создаются и удаляются вместе
4. Они могут общаться через `localhost`
5. При масштабировании POD масштабируются оба контейнера

### Схема работы веб-сервера с мониторингом

```
┌─────────────────────────────────────────────────────────┐
│  POD: web-server-monitored                               │
│  IP: 10.244.1.15                                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │                                                   │   │
│  │  Container: web-server                            │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  nginx:latest                                │ │   │
│  │  │  Порт: 80                                    │ │   │
│  │  │  Обслуживает HTTP-запросы                   │ │   │
│  │  │  Volume: /usr/share/nginx/html               │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │         │                                          │   │
│  │         │ (метрики через localhost)               │   │
│  │         ▼                                          │   │
│  │  Container: cadvisor                              │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  cadvisor:latest                             │ │   │
│  │  │  Порт: 8080                                  │ │   │
│  │  │  Собирает метрики контейнеров                │ │   │
│  │  │  Доступ: http://localhost:8080/metrics       │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  │                                                   │   │
│  └──────────────────────────────────────────────────┘   │
│                                                          │
│  Внешний доступ:                                         │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Service → localhost:80 → web-server            │   │
│  │  Service → localhost:8080 → cadvisor            │   │
│  └──────────────────────────────────────────────────┘   │
│                                                          │
│  Масштабирование:                                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │  kubectl scale deployment web-app --replicas=3   │   │
│  │  → Создаются 3 POD, каждый с обоими контейнерами│   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

</details>

---

## Резюме

### Основные концепции

- **Много-контейнерные PODs** позволяют запускать несколько контейнеров в одном POD
- Контейнеры в одном POD имеют **общий lifecycle**, **сеть** и могут использовать **общие volumes**
- Не нужно настраивать Service для общения между контейнерами в одном POD

### Паттерны проектирования

- **Sidecar** - дополнительный контейнер для метрик, логирования, мониторинга
- **Adapter** - нормализация и преобразование данных
- **Ambassador** - проксирование и роутинг трафика

### Преимущества

- Упрощенное управление связанными сервисами
- Автоматическое масштабирование всех контейнеров вместе
- Общая сеть через localhost
- Совместное использование volumes
- Разделение ответственности без объединения кода

### Когда использовать

- Когда два сервиса должны работать вместе с одинаковым lifecycle
- Когда нужен один экземпляр вспомогательного сервиса на каждый экземпляр основного
- Когда сервисы должны обмениваться данными через файловую систему
- Когда нужно избежать сложности настройки Service для внутренней коммуникации

---

Ну вот и все для этой лекции. Перейди в раздел упражнений и поработай c multicontainer PODs. Увидимся на следующей лекции.

---

## Связанные темы

- **[K-09-1-Rolling-Updates-and-Rollbacks](K-09-1-Rolling-Updates-and-Rollbacks.md)** — обновления и откаты
- **[K-09-2-Command-and-Arguments-Docker](K-09-2-Command-and-Arguments-Docker.md)** — команды и аргументы в Docker контейнерах
- **[K-09-3-Command-and-Arguments-k8s](K-09-3-Command-and-Arguments-k8s.md)** — команды и аргументы в Kubernetes Pod
- **[K-09-4-Environment-Variables-in-Applications](K-09-4-Environment-Variables-in-Applications.md)** — переменные среды в приложениях
- **[K-09-5-Configure-ConfigMaps-in-Applications](K-09-5-Configure-ConfigMaps-in-Applications.md)** — настройка ConfigMaps в приложениях
- **[K-09-6-Configure-Secrets-in-Applications](K-09-6-Configure-Secrets-in-Applications.md)** — настройка Secrets в приложениях
- **[K-09-7-Multi-Container-PODs](K-09-7-Multi-Container-PODs.md)** — мультиконтейнерные Pod **← Текущая тема**
- **[K-09-8-Init-Containers](K-09-8-Init-Containers.md)** — Init контейнеры
- **[K-09-9-Self-Healing-Apps](K-09-9-Self-Healing-Apps.md)** — самовосстанавливающиеся приложения
- **[K-09-10-Autoscaling-Benefits](K-09-10-Autoscaling-Benefits.md)** — преимущества автоматического масштабирования
- **[K-09-11-HPA-Architecture](K-09-11-HPA-Architecture.md)** — архитектура Horizontal Pod Autoscaler
- **[K-09-12-VPA-Architecture](K-09-12-VPA-Architecture.md)** — архитектура Vertical Pod Autoscaler
- **[K-09-13-Pod-In-Place-Resize](K-09-13-Pod-In-Place-Resize.md)** — изменение размера Pod на месте

---

## Что дальше?

В следующей теме [K-09-8-Init-Containers](K-09-8-Init-Containers.md) мы рассмотрим Init контейнеры — специализированные контейнеры, которые выполняются перед запуском основных контейнеров Pod и используются для инициализации и подготовки окружения.

---