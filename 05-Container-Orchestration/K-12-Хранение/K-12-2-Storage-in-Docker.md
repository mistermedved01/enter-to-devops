[🏠 Главная](../../README.md) → [☸️ Container-Orchestration](../../README.md#-container-orchestration) → [💾 K-12-Хранение](../../README.md#-k-12-хранение)

---

# 💾K-12-2-Storage-in-Docker
>Хранение данных в Docker: структура /var/lib/docker, многоуровневая архитектура образов, Copy-on-Write механизм, volumes, storage drivers

---

<details>
<summary><b>📁Где Docker хранит данные</b></summary>

---

## Связь с предыдущей темой

В теме [K-12-1-Enter-Container-Storage](K-12-1-Enter-Container-Storage.md) мы рассмотрели две ключевые концепции хранения в Docker: Storage Drivers и Volume Driver Plugins.

В этой теме детально изучаем Storage Drivers и механизмы работы с хранилищем.

---

## Локальное хранилище Docker

Когда мы устанавливаем Docker в систему, он создает некоторую структуру папок в каталоге `/var/lib/docker`.

Здесь Docker по умолчанию хранит все свои данные.

### Структура /var/lib/docker

```
/var/lib/docker/
├── overlay2/          # Слои файловой системы (storage driver)
├── containers/        # Файлы контейнеров
├── image/            # Метаданные образов
├── volumes/          # Тома (volumes)
├── network/          # Сетевые конфигурации
├── swarm/            # Docker Swarm данные
└── ...
```

### Назначение директорий

Здесь хранятся файлы, связанные с образами и контейнерами, запущенными на этом докер-хосте.

- **overlay2/** — слои файловой системы, создаваемые storage driver'ом (overlay2). Здесь хранятся все слои образов и контейнеров. Имя директории зависит от используемого storage driver'а (может быть `aufs`, `devicemapper`, `btrfs` и т.д.)

- **containers/** — все файлы, относящиеся к контейнерам, хранятся в папке `containers`. Сюда входят метаданные контейнеров, логи, файлы конфигурации и другие данные, специфичные для каждого контейнера

- **image/** — файлы, связанные с образами, хранятся в папке `image`. Здесь находятся метаданные образов, информация о слоях, манифесты и другая информация, необходимая для работы с образами Docker

- **volumes/** — любые тома, созданные для докер-контейнеров, создаются в папке `volumes`. Каждый созданный том получает свою поддиректорию здесь, где хранятся данные, которые должны сохраняться между перезапусками контейнеров

- **network/** — сетевые конфигурации Docker хранятся в папке `network`. Здесь находятся настройки сетей, bridge-интерфейсов, IP-адресов и других сетевых параметров

- **swarm/** — данные, связанные с Docker Swarm (оркестрацией контейнеров), хранятся в папке `swarm`. Сюда входят конфигурации кластера, состояние сервисов, секреты и другие данные Swarm-режима

---

</details>

<details>
<summary><b>🏗️Многоуровневая архитектура Docker</b></summary>

---

## Как Docker хранит образы и контейнеры

Docker использует многоуровневую (слоеную) архитектуру для организации хранения файлов образов и контейнеров.

Каждый слой представляет собой неизменяемый набор изменений файловой системы.

---

## Слои образа

Docker создает образы в многоуровневой архитектуре, где каждая инструкция в Dockerfile формирует отдельный слой.

Каждый слой фиксирует изменения относительно предыдущего слоя, что позволяет эффективно переиспользовать общие части между разными образами.

### Пример многоуровневого образа

```
┌─────────────────────────────────────────────────────────┐
│  Слой 5: CMD ["python", "app.py"]                       │
│  (точка входа)                                          │
├─────────────────────────────────────────────────────────┤
│  Слой 4: COPY app.py /app/                              │
│  (исходный код)                                         │
├─────────────────────────────────────────────────────────┤
│  Слой 3: RUN pip install flask                          │
│  (зависимости Python)                                   │
├─────────────────────────────────────────────────────────┤
│  Слой 2: RUN apt-get install -y python3                 │
│  (пакеты APT)                                           │
├─────────────────────────────────────────────────────────┤
│  Слой 1: FROM ubuntu:20.04                              │
│  (базовая ОС)                                           │
└─────────────────────────────────────────────────────────┘
```

В приведенном примере:
- Слой 1 содержит базовую операционную систему Ubuntu
- Слой 2 добавляет установленные пакеты APT
- Слой 3 включает зависимости Python
- Слой 4 содержит исходный код приложения
- Слой 5 определяет точку входа образа

---

## Размеры слоев

Каждый слой хранит только изменения относительно предыдущего слоя, что оптимизирует использование дискового пространства.

Типичное распределение размеров:
- Базовый образ Ubuntu: ~80 МБ
- Установленные пакеты APT: ~450 МБ
- Остальные слои: обычно небольшие

---

## Преимущества многоуровневой архитектуры

Рассмотрим сценарий, когда создается второе приложение с похожим Dockerfile.

Если второе приложение использует тот же базовый образ (Ubuntu) и те же зависимости (Python, Flask), но отличается исходным кодом и точкой входа, Docker сможет переиспользовать общие слои.

### Переиспользование слоев

```
┌─────────────────────────────────────────────────────────┐
│  Приложение 1                                           │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Слой 5: CMD ["python", "app1.py"]               │   │
│  │  Слой 4: COPY app1.py /app/                      │   │
│  │  Слой 3: RUN pip install flask                   │   │
│  │  Слой 2: RUN apt-get install -y python3          │   │
│  │  Слой 1: FROM ubuntu:20.04                       │   │
│  └──────────────────────────────────────────────────┘   │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Кэш Docker                                      │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Слой 1, 2, 3 (переиспользуются)            │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────┘   │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Приложение 2 (новая сборка)                     │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Слой 5: CMD ["python", "app2.py"]          │ │   │
│  │  │  Слой 4: COPY app2.py /app/                 │ │   │
│  │  │  Слой 3: (из кэша)                          │ │   │
│  │  │  Слой 2: (из кэша)                          │ │   │
│  │  │  Слой 1: (из кэша)                          │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

При выполнении `docker build` для второго приложения Docker определяет, что первые три слоя идентичны уже собранным слоям первого приложения.

Вместо повторной сборки Docker использует слои из кэша, который хранит все ранее собранные слои на хосте.

Создаются только новые слои (исходный код и точка входа), которые также добавляются в кэш.

Этот механизм значительно ускоряет сборку образов и оптимизирует использование дискового пространства.

---

## Обновление образов

Тот же принцип применяется при обновлении кода приложения.

При изменении исходного кода (например, `app.py`) Docker переиспользует все неизмененные слои из кэша и пересобирает только измененные слои и все последующие.

Это существенно сокращает время пересборки образов при обновлениях.

---

</details>

<details>
<summary><b>📦Слои образа и контейнера</b></summary>

---

## Структура слоев

Слои образа организованы иерархически: базовый слой находится внизу, последующие слои накладываются поверх него.

Структура типичного образа: базовый образ (Ubuntu) → установленные пакеты → зависимости → исходный код → точка входа.

Все слои создаются при выполнении команды `docker build`, формируя финальный образ Docker.

### Слои образа (только чтение)

```
┌─────────────────────────────────────────────────────────┐
│  Образ Docker (Read-Only)                               │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Слой 5: CMD ["python", "app.py"]                │   │
│  ├──────────────────────────────────────────────────┤   │
│  │  Слой 4: COPY app.py /app/                       │   │
│  ├──────────────────────────────────────────────────┤   │
│  │  Слой 3: RUN pip install flask                   │   │
│  ├──────────────────────────────────────────────────┤   │
│  │  Слой 2: RUN apt-get install -y python3          │   │
│  ├──────────────────────────────────────────────────┤   │
│  │  Слой 1: FROM ubuntu:20.04                       │   │
│  └──────────────────────────────────────────────────┘   │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Контейнер (Read-Write)                          │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Container Layer (R/W)                      │ │   │
│  │  │  - Логи                                     │ │   │
│  │  │  - Временные файлы                          │ │   │
│  │  │  - Измененные файлы                         │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

После завершения создания образа мы не можем изменять содержимое этих слоев, они доступны только для чтения, а изменить их возможно только через запуск новой сборки.

---

## Слой контейнера

Когда мы запускаем контейнер, основанный на этом образе при помощи команды `docker run`, Docker создает контейнер на основе этих слоев, а далее создает новый слой поверх слоев образа, с которого можно не только читать, но и в который можно писать.

Слой с возможностью записи используется для хранения и изменения данных, созданных контейнером. Таких данных, как:
- Логи
- Временные файлы
- Прочие вещи, необходимые для работы приложения

В него также попадает любой файл, измененный пользователем в этом контейнере.

---

## Жизненный цикл слоя контейнера

Срок жизни этого слоя ограничен временем, пока жив контейнер.

Когда контейнер разрушается, этот слой со всеми сохраненные в нем изменения уничтожается.

Помни, что одни и те же слои образа делятся между всеми контейнерами, запущенными с использованием этого образа.

---

</details>

<details>
<summary><b>✍️Copy-on-Write механизм</b></summary>

---

## Проблема: изменение файлов в слоях только для чтения

При создании нового файла в контейнере (например, `temp.txt`) он создается в слое контейнера, который имеет права на чтение и запись.

Однако файлы в слоях образа доступны только для чтения, что предотвращает их прямое изменение.

---

## Пример: изменение исходного кода

Рассмотрим ситуацию, когда исходный код приложения включен в образ.

Код находится в одном из слоев образа и доступен только для чтения после запуска контейнера.

Возникает вопрос: как изменить файл, если он находится в read-only слое, который может использоваться несколькими контейнерами одновременно?

---

## Решение: Copy-on-Write

Docker решает эту проблему с помощью механизма **Copy-on-Write (CoW)**.

При попытке изменить файл из read-only слоя Docker автоматически создает копию этого файла в read-write слое контейнера перед внесением изменений.

Все последующие изменения применяются к копии файла в слое контейнера, в то время как оригинальный файл в слое образа остается неизменным.

### Схема Copy-on-Write

```
┌──────────────────────────────────────────────────────────┐
│  До изменения файла                                      │
│  ┌──────────────────────────────────────────────────┐    │
│  │  Container Layer (R/W)                           │    │
│  │  (пусто)                                         │    │
│  ├──────────────────────────────────────────────────┤    │
│  │  Image Layer 4: app.py (Read-Only)               │    │
│  │  ┌─────────────────────────────────────────────┐ │    │
│  │  │  def hello():                               │ │    │
│  │  │      return "Hello"                         │ │    │
│  │  └─────────────────────────────────────────────┘ │    │
│  └──────────────────────────────────────────────────┘    │
│                        │                                 │
│            Попытка изменить app.py                       │ 
│                        │                                 │
│                        ▼                                 │ 
│  ┌──────────────────────────────────────────────────┐    │
│  │  После изменения файла                           │    │
│  │  ┌──────────────────────────────────────── ─────────┐ │
│  │  │  Container Layer (R/W)                           │ │
│  │  │  ┌─────────────────────────────────────────────┐ │ │
│  │  │  │  app.py (копия)                             │ │ │
│  │  │  │  def hello():                               │ │ │
│  │  │  │      return "Hello World"                   │ │ │
│  │  │  └─────────────────────────────────────────────┘ │ │
│  │  └──────────────────────────────────────────────────┘ │
│  │  ├──────────────────────────────────────────────────┤ │
│  │  │  Image Layer 4: app.py (Read-Only)               │ │
│  │  │  ┌─────────────────────────────────────────────┐ │ │
│  │  │  │  def hello():                               │ │ │
│  │  │  │      return "Hello"                         │ │ │
│  │  │  └─────────────────────────────────────────────┘ │ │
│  │  └──────────────────────────────────────────────────┘ │
│  └───────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────────┘
```

---

## Важные моменты

Слои образа остаются неизменными и доступны только для чтения. Образ сохраняет свою целостность до тех пор, пока не будет пересобран с помощью `docker build`.

Файлы, которые не были изменены в контейнере, физически не существуют в слое контейнера — они читаются напрямую из соответствующих слоев образа.

---

## Удаление контейнера

При удалении контейнера все данные, хранящиеся в его read-write слое, также удаляются.

Это включает все изменения файлов (например, изменения в `app.py`) и все новые файлы, созданные в контейнере.

---

</details>

<details>
<summary><b>💾Volumes (Тома)</b></summary>

---

## Проблема: сохранение данных

Для сохранения данных между перезапусками контейнера необходимо использовать постоянное хранилище.

Например, при работе с базой данных требуется сохранять данные, созданные контейнером.

Для этого в контейнер добавляется постоянный том (volume).

---

## Создание тома

```bash
docker volume create data_volume
```

Данная команда создает папку с именем `data_volume` в каталоге `/var/lib/docker/volumes`.

---

## Монтирование тома в контейнер

Том монтируется в контейнер при запуске с помощью опции `-v`:

```bash
docker run -v data_volume:/var/lib/mysql mysql
```

Docker создает контейнер и монтирует том в указанную директорию (`/var/lib/mysql`). Все данные, записываемые базой данных, фактически сохраняются в томе на хосте Docker.

Данные остаются доступными даже после остановки или удаления контейнера.

### Схема Volume Mounting

```
┌─────────────────────────────────────────────────────────┐
│  Docker Host                                            │
│  ┌──────────────────────────────────────────────────┐   │
│  │  /var/lib/docker/volumes/data_volume/            │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Данные БД (сохраняются)                    │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────┘   │
│                        │                                │
│                        │ Монтирование                   │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Контейнер MySQL                                 │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  /var/lib/mysql/                            │ │   │
│  │  │  (смонтированный том)                       │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

## Автоматическое создание тома

Если том не был создан заранее с помощью `docker volume create`, Docker автоматически создаст его при запуске контейнера.

Например, при выполнении команды:

```bash
docker run -v data_volume_2:/var/lib/mysql mysql
```

Docker автоматически создаст том `data_volume_2` и подключит его к контейнеру.

Все созданные тома можно найти в директории `/var/lib/docker/volumes`.

---

## Типы монтирования

Монтирование тома из директории `/var/lib/docker/volumes` называется **volume mounting**.

В некоторых случаях требуется использовать данные, уже размещенные в другом месте файловой системы хоста, без переноса в стандартную директорию томов.

---

## Bind Mounting

Для монтирования существующей директории хоста используется **bind mounting**.

Например, если данные базы данных должны храниться в директории `/data/mysql` на хосте, а не в стандартной директории томов Docker:

```bash
docker run -v /data/mysql:/var/lib/mysql mysql
```

При указании полного пути Docker монтирует существующую директорию хоста в контейнер, а не создает новый том.

### Сравнение типов монтирования

```
┌─────────────────────────────────────────────────────────┐
│  Volume Mounting                                        │
│  ┌──────────────────────────────────────────────────┐   │
│  │  docker run -v data_volume:/var/lib/mysql        │   │
│  │                                                  │   │
│  │  Том создается в:                                │   │
│  │  /var/lib/docker/volumes/data_volume/            │   │
│  └──────────────────────────────────────────────────┘   │
│                                                         │
│  Bind Mounting                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │  docker run -v /data/mysql:/var/lib/mysql        │   │
│  │                                                  │   │
│  │  Монтируется существующая директория:            │   │
│  │  /data/mysql/                                    │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

Таким образом, существует два типа монтирования:
- **Volume mounting** — монтирует том из каталога томов
- **Bind mounting** — монтирует каталог из любого места на докер-хосте

---

</details>

<details>
<summary><b>🔧Опции -v и --mount</b></summary>

---

## Старый и новый стиль

Опция `-v` является устаревшим синтаксисом для монтирования томов.

Современный подход — использование опции `--mount`, которая обеспечивает более явный и гибкий синтаксис, хотя `-v` все еще широко используется на практике.

---

## Синтаксис --mount

При использовании `--mount` параметры указываются в формате `ключ=значение`.

Примеры использования:

```bash
# Старый стиль (volume mounting)
docker run -v data_volume:/var/lib/mysql mysql

# Новый стиль (volume mounting)
docker run --mount type=volume,source=data_volume,target=/var/lib/mysql mysql
```

```bash
# Старый стиль (bind mounting)
docker run -v /data/mysql:/var/lib/mysql mysql

# Новый стиль (bind mounting)
docker run --mount type=bind,source=/data/mysql,target=/var/lib/mysql mysql
```

Для bind mounting параметр `type` устанавливается в `bind`, `source` указывает путь на хосте, а `target` — путь в контейнере.

---

## Преимущества --mount

- Более явный и понятный синтаксис
- Легче читать и понимать
- Больше опций для настройки
- Рекомендуемый способ в документации Docker

---

</details>

<details>
<summary><b>🚗Storage Drivers (Драйверы хранилища)</b></summary>

---

## Кто отвечает за операции хранения?

За выполнение операций с хранилищем отвечают **storage drivers**.

Они обеспечивают:
- Сохранение многоуровневой архитектуры
- Создание read-write слоя для контейнеров
- Реализацию механизма Copy-on-Write
- Управление слоями файловой системы

---

## Что такое Storage Drivers

Docker использует storage drivers для реализации многоуровневой архитектуры образов и контейнеров.

Storage Drivers — это низкоуровневые компоненты, управляющие организацией и хранением слоев файловой системы.

### Схема работы Storage Drivers

```
┌─────────────────────────────────────────────────────────┐
│  Docker Engine                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Storage Driver (overlay2)                       │   │
│  │  ┌─────────────────────────────────────────────┐ │   │
│  │  │  Управление слоями                          │ │   │
│  │  │  Copy-on-Write                              │ │   │
│  │  │  Объединение слоев                          │ │   │
│  │  └─────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────┘   │
│                        │                                │
│                        ▼                                │
│  ┌──────────────────────────────────────────────────┐   │
│  │  /var/lib/docker/overlay2/                       │   │
│  │  (файловая система хоста)                        │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

---

## Популярные Storage Drivers

Распространенные storage drivers:

- **overlay2** (рекомендуемый) — современный и производительный драйвер
- **overlay** — предшественник overlay2
- **AUFS** (Another Union File System) — устаревший, но все еще встречается
- **BTRFS** (B-tree File System) — для систем с Btrfs
- **ZFS** (Z File System) — для систем с ZFS
- **device-mapper** — используется в некоторых дистрибутивах
- **fuse.overlayfs** — альтернативная реализация overlay

Некоторые драйверы устарели, но могут использоваться в legacy-системах.

---

## Выбор Storage Driver

Выбор драйвера хранилища зависит от используемой ОС.

### По умолчанию

В современных версиях Docker (18+) на Ubuntu по умолчанию используется `overlay2`.

В более ранних версиях Docker использовал `aufs`, который был недоступен в некоторых дистрибутивах (Fedora, CentOS), где приходилось использовать `device-mapper`.

### Автоматический выбор

Docker автоматически выбирает подходящий storage driver на основе доступных возможностей операционной системы.

Однако автоматический выбор не всегда оптимален. При возникновении проблем может потребоваться ручная настройка драйвера с учетом особенностей конкретной ОС и версии ядра.

До появления `overlay2` (примерно до 2018 года) выбор storage driver был более критичной проблемой, сейчас ситуация значительно улучшилась.

---

## Характеристики драйверов

Различные storage drivers обеспечивают разные характеристики производительности и стабильности.

Выбор драйвера должен основываться на требованиях приложения и политиках организации.

### Сравнение драйверов

| Драйвер | Производительность | Стабильность | Поддержка |
|---------|-------------------|--------------|-----------|
| overlay2 | Высокая | Высокая | Рекомендуемый |
| overlay | Средняя | Высокая | Устаревший |
| aufs | Средняя | Средняя | Устаревший |
| device-mapper | Средняя | Высокая | Legacy |
| btrfs | Высокая | Средняя | Специфичный |
| zfs | Высокая | Высокая | Специфичный |

---

## Проверка текущего драйвера

Чтобы узнать, какой storage driver используется в вашей системе:

```bash
docker info | grep "Storage Driver"
```

Или:

```bash
docker system info
```

---

## Дополнительная информация

Для более глубокого изучения storage drivers рекомендуется начать с официальной документации Docker, а затем изучить обсуждения и issues в репозитории Docker на GitHub.

---

</details>

---

## Резюме

### Где Docker хранит данные

- **/var/lib/docker/** — основной каталог для всех данных Docker
- **containers/** — файлы контейнеров
- **image/** — метаданные образов
- **volumes/** — тома

### Многоуровневая архитектура

- Каждая инструкция в Dockerfile создает новый слой
- Слои образа доступны только для чтения
- Контейнер имеет дополнительный слой для чтения и записи
- Слои переиспользуются между образами и контейнерами

### Copy-on-Write (CoW)

- При изменении файла создается копия в слое контейнера
- Оригинальные файлы в слоях образа остаются неизменными
- Изменения в слое контейнера удаляются при удалении контейнера

### Volumes

- **Volume mounting** — тома в `/var/lib/docker/volumes/`
- **Bind mounting** — монтирование существующих директорий
- Данные в volumes сохраняются после удаления контейнера

### Storage Drivers

- Управляют многоуровневой архитектурой
- Обеспечивают Copy-on-Write механизм
- `overlay2` — рекомендуемый драйвер для большинства систем
- Выбор зависит от ОС и требований

---

## Связанные темы

- **[K-12-1-Enter-Container-Storage](K-12-1-Enter-Container-Storage.md)** — введение в концепции хранения в Docker
- **[K-12-2-Storage-in-Docker](K-12-2-Storage-in-Docker.md)** — volumes в Docker **← Текущая тема**
- **[K-12-3-Volume-Driver-Plugins-in-Docker](K-12-3-Volume-Driver-Plugins-in-Docker.md)** — volume driver plugins
- **[K-12-4-CSI](K-12-4-CSI.md)** — Container Storage Interface
- **[K-12-5-Volumes](K-12-5-Volumes.md)** — volumes в Kubernetes, типы volumes и их использование
- **[K-12-6-Persistent-Volumes](K-12-6-Persistent-Volumes.md)** — Persistent Volumes, централизованное управление хранилищем
- **[K-12-7-Persistent-Volume-Claims](K-12-7-Persistent-Volume-Claims.md)** — Persistent Volume Claims, запросы на хранилище

---

## Что дальше?

В следующей теме [K-12-3-Volume-Driver-Plugins-in-Docker](K-12-3-Volume-Driver-Plugins-in-Docker.md) мы изучим volume driver plugins, которые позволяют Docker работать с различными системами хранения данных, включая локальные, сетевые и облачные хранилища.

---